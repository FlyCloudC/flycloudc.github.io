<h1>浅谈Functor和Monad</h1>

<hr>

<p>
  很久以前，我看到Haskell里的Functor、Monad这种高深词汇就害怕，后来发现其实不是什么特别难的东西。本文采用循序渐进的方式，通过举例子说明什么是Functor和Monad。
</p>

<hr>

<h2>一、值</h2>

<ul>
  <li>一只羊、一个苹果、一个人、……共同的特点是“1”。</li>
  <li>二只羊、二个苹果、二个人、……共同的特点是“2”。</li>
  <li>三只羊、三个苹果、三个人、……共同的特点是“3”。</li>
  <li>……</li>
</ul>

<p>
  1、2、3都是值（value）。
</p>

<hr>

<h2>二、类型</h2>

<p>
  除了数字是值以外，还有别的类型的值。
</p>

<ul>
  <li>“数字”有1、2、3、……</li>
  <li>“判断”有“真”和“假”。</li>
  <li>“方向”有“上”、“下”、“左”、“右”。</li>
  <li>……</li>
</ul>

<p>
  把相似的抽象概念归为一类，称之为“类型”（type）。
</p>

<hr>

<h2>三、类型构造器</h2>

<ul>
  <li>我们可以写出“数字的列表”，比如[1,3,6,3]。“数字的列表”是一个类型。</li>
  <li>我们可以写出“方向的列表”，比如[上，上，下，下]。“方向的列表”是一个类型。</li>
  <li>……</li>
</ul>

<p>
  总结一下就是：如果A是一个类型，那么“A的列表”就是一个类型。
</p>

<p>
  而“____的列表”不是类型。它是什么呢？是一个“类型构造器”：往“____”上填一个类型，就能构造出一个类型。
</p>

<ul>
  <li>比如，填上“判断”，就能构造出“判断的列表”。[真，真，假，假]就是一个“判断的列表”。</li>
  <li>又比如，给它填上“数字的列表”，它就能构造出“‘数字的列表’的列表”。[[3,0,0],[0,2,0],[0,0,1]]就是一个“‘数字的列表’的列表”。</li>
</ul>

<p>
  还有别的“类型构造器”吗？有的。比如说：
</p>

<ul>
  <li>长度不超过1的____的列表</li>
  <li>____的集合</li>
  <li>由一个____算出一个数字的方法</li>
  <li>过一会才能拿到的____</li>
</ul>

<p>
  再次强调，类型构造器<b>不是</b>类型。比如：“____的列表”不是类型，而是类型构造器。而“整数的列表”是类型。
</p>

<hr>

<h2>四、Functor</h2>

<p>
  又有人发现，某些“类型构造器”会满足同样的性质。
</p>

<p>
  比如，假设你已经掌握了“由一个A算出一个B的方法”，那么：
<ul>
  <li>如果你有一个“A的列表”，那么你一定有办法构造一个“B的列表”。</li>
  <li>如果你有一个“A的集合”，那么你一定有办法构造一个“B的集合”。</li>
  <li>如果你有一个“长度不超过1的A的列表”，那么你一定有办法构造一个“长度不超过1的B的列表”。</li>
  <li>如果你有一个“由一个C算出一个A的方法”，那么你一定有办法构造一个“由一个C算出一个B的方法”。</li>
  <li>……</li>
</ul>
这种性质被称为Functor，上面的这种操作叫map。第三个例子中的“长度不超过1的A的列表”，在某些语言里叫"Option"或者“可为空的”。
</p>

<p>
  注意，Functor是<b>类型构造器</b>的性质，而不是<b>类型</b>的性质。另外，常常会把“xxx具有Functor性质”简称为“xxx是一个Functor”。
</p>

<p>
  一个有趣的事情：“由一个___算出一个数字的方法”不是Functor。而“由一个数字算出一个___的方法”却是Functor。
</p>

<hr>

<h2>五、Monad</h2>

<p>
  Monad在Functor的基础上更进一步。<br />
<ul>
  <li>如果你有一个“A的列表”，和一个“由一个<u>A</u>算出一个<u>B的列表</u>的方法，那么你一定有办法构造一个“B的列表”。</li>
  <li>如果你有一个“A的集合”，和一个“由一个A算出一个B的集合的方法，那么你一定有办法构造一个“B的集合”。</li>
  <li>如果你有一个“长度不超过1的A的列表”，和一个“由一个A算出一个长度不超过1的B的列表的方法”，那么你一定有办法构造一个“长度不超过1的B的列表”。</li>
  <li>如果你有一个“进行几次神秘仪式才能拿到的A”，和一个“由一个A算出一个<u>进行几次神秘仪式才能拿到的B</u>的方法，那么你一定有办法构造一个“进行几次神秘仪式才能拿到的B”。</li>
  <li>……</li>
</ul>
这种性质就是Monad，上面那种操作叫做bind。第四个例子里的“神秘仪式”可以代表“读取事先存在某处的数据”，或者“读取键盘输入”。
</p>

<p>
  同样的，要注意Monad是类型构造器的性质，而不是类型的性质。
</p>

<p>
  思考各种类型构造器的bind代表什么，是一件有趣的事情。不是随便一种实现方式都是合理的bind，它需要满足一些特定的性质。在这里，我不想提及这些范畴论公式，因为这篇文章只是浅谈。一般来说，你能想到的最自然的方式就是合理的。
</p>

<p>
  让我们看一个具体例子：列表的bind。首先我有一个<u>A的列表</u>和一个<u>由一个A算出一个B的列表的方法</u>，那我就可以对于其中的每个A，算出一个<u>B的列表</u>。现在我们需要构造一个B的列表作为最终的结果。最自然的想法就是把刚刚得到的每个<u>B的列表</u>全部拼接起来。这就是一个合理的bind。
</p>

<p>
  另一个例子是“可为空的”的bind。首先我有一个<u>可为空的A</u>和一个<u>由一个A算出一个可为空的B的方法</u>，那就分类讨论：如果这个<u>可为空的A</u>是空的，那就啥也算不了了，于是只能把空的B作为结果；否则就对A做那个计算，得到一个可为空的B正好作为结果返回。这就是“可为空的”的bind。写成代码就是下面的样子：
  <code>if (a为空) {
  return 空
}
... // 此处a一定不为空，拿着a继续做一些计算
</code>
  很多语言都提供了像“.?”这样的语法糖，来简化上面这一长串东西。
</p>

<hr>

<h2>延申阅读</h2>

<ul>
  <li><a
      href="https://drsexplorer.gitbooks.io/learnyouahaskell-zh/content/zh-cn/ch11/functors-applicative-functors-and-monoids.html">《Haskell
      趣学指南》第11章 Functors, Applicative Functors 与 Monoids</a></li>（需要有Haskell基础）
</ul>
