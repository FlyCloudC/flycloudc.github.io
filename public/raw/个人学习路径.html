<h1>个人学习路径</h1>

<hr>

<blockquote>
  各种各样的编程语言来来去去。在你的生命中，可能会学到好几门。今天是Python和Java。昨天，是Pascal和Cobol。再往前还有Fortran和Lisp。谁知道明天是什么？在这个日新月异的领域，你需要能够迅速适应变化。一个好的程序员必须学习<b>超越任何具体编程语言的编程原则</b>。从函数式的角度来学习编程，是领会这种原则的绝佳角度。从头开始学习一门新语言，你就有机会反思<u>编程</u>与<u>用某个特定的语言编程</u>的区别所在。
  <br /><br />
  <i>—— CS3110, 1.3. Look to Your Future</i>
</blockquote>

<hr>

<p>以下的英文材料都可以使用<a href="https://immersivetranslate.com/zh-Hans/">沉浸式翻译</a>转成中文。</p>

<h3>Scheme</h3>

<p>最小的编程语言。该有功能的都有了，没有的都能组装出来。</p>

<ul>
  <li>The Little Schemer</li>
  <ul>
    <li>介绍Scheme基本功能。内容不多，但非常详细。有点小幽默。最后会用Scheme解释Scheme。</li>
  </ul>

  <li>The Seasoned Schemer</li>
  <ul>
    <li>前一本的续集。介绍了Scheme中的<i>副作用</i>和<i>捕获延续</i>。</li>
  </ul>

  <li>计算机程序的构造与解释（SICP）</li>
  <ul>
    <li>讲解如何构建各种抽象，这是计算机科学的主题。</li>
    <li>在线阅读：
      <a href="https://sarabander.github.io/sicp/">sarabander</a>（这个好看一点）、
      <a
        href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book.html">MIT出版社</a>
    </li>
    <li>书有中文版，机械工业出版社</li>
    <li>视频：<a href="https://www.bilibili.com/video/BV1Xx41117tr">bilibili</a>（相比书中内容有所增删，中文字幕）</li>
  </ul>
</ul>

<p>进阶：</p>

<ul>
  <li>Essentials of Programming Languages</li>
  <ul>
    <li>集大成者，用Scheme写出了各种语言的解释器、编译器。</li>
  </ul>

  <li>
    <a href="https://legacy.cs.indiana.edu/~dyb/papers/3imp.pdf">
      Three Implementation Models for Scheme
    </a>
  </li>
  <ul>
    <li>
      三种Scheme到抽象机器码的编译器。一个用链表当函数调用栈，一个用数组当函数调用栈。讲了词法作用域、可变变量、call/cc的实现。最后还有一个FFP Machine的实现，很少见。
    </li>
    <li>
      <a href="https://www.burgerrg.com/TR413.pdf">The Scheme
        Machine</a>：进一步将上文的抽象机器码编译到一个硬件机器上。这是一个完全运行Scheme的机器，里面的机器码操纵的都是Scheme中的对象。
    </li>
  </ul>
</ul>

<p>关于能力安全：</p>

<ul>
  <li><a href="https://files.spritely.institute/papers/spritely-core.html">Spritely核心：分布式对象与能力安全</a></li>
  <ul>
    <li>图文并茂。把词法作用域作为访问控制的手段。“如果你没有它，你就不能使用它。”</li>
  </ul>

  <li><a href="http://mumble.net/~jar/pubs/secureos/secureos.html">基于Lambda演算的安全内核</a></li>
  <ul>
    <li>其中包含了一个与操作系统的类比。</li>
  </ul>
</ul>

<h3>Smalltalk</h3>

<p>Smalltalk不只是编程语言，它还是最早的带图形界面的操作系统。</p>

<ul>
  <li>
    <a href="https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html">Smalltalk背后的设计原则</a>
  </li>
  <ul>
    <li>
      如果一个系统服务于<i>创造</i>，它必须能被个人<i>完全理解</i>。
    </li>
  </ul>

  <li>Squake by example</li>
  <ul>
    <li><a href="https://github.com/hpi-swa-lab/SqueakByExample-english/releases/download/6.0/SBE-6.0.pdf"> PDF下载</a>
    </li>
    <li>带你游览Smalltalk的世界（这不是比喻，它真的是一个世界）。</li>
    <li>第13章讲了“一切皆Object”的一些事情。</li>
  </ul>

  <li>
    <a href="https://ia801909.us.archive.org/7/items/ALittleSmalltalkBook/ALittleSmalltalk.pdf">
      A Little Smalltalk
    </a>
  </li>
  <ul>
    <li>
      Part Two中讲解了一个Smalltalk系统的C语言实现。在这里面可以看到如何将各种Primitive包装成Object，实现“一切皆Object”的灵活性。
    </li>
  </ul>
</ul>

<h3>OCaml</h3>

<p>带有<i>静态类型系统</i>，不运行就检查出程序中的某些bug。变量代表一个值，而不是“保存一个值的空间”。</p>

<ul>
  <li>cs3110</li>
  <ul>
    <li>课程讲义：<a href="https://cs3110.github.io/textbook/cover.html">《OCaml 编程：正确 + 高效 + 优美》</a></li>
    <li>以自身为例，讲解“如何学习一门编程语言”。先了解程序的语义，然后再逐步深入具体细节。</li>
    <li>如何通过模块构建抽象屏障，来约束正确性，以几种数据结构为例。</li>
    <li>附录中讲了<i>时间复杂度</i>，把来由讲清楚了。</li>
  </ul>

  <li><a href="https://try.ocamlpro.com/">在线运行OCaml</a></li>
</ul>

<p>进阶：</p>

<ul>
  <li><a href="https://dev.realworldocaml.org/">Real World OCaml</a></li>
  <ul>
    <li>介绍高级特性：First-Class module、GADT</li>
    <li>介绍面向对象系统。与主流语言的都不一样，它基于“结构”，而非基于“名义”。</li>
    <li>介绍值在内存中的表示方式，以及分代gc策略。</li>
  </ul>
</ul>

<h3>F#</h3>

<p>微软重制版OCaml。不包含OCaml的进阶部分的功能。除此之外语法几乎一样，但是看着更干净。</p>

<ul>
  <li><a href="https://fsharpforfunandprofit.com/">F# for Fun and Profit</a></li>
  <ul>
    <li>一个网站，F#入门，以及各种F#技巧</li>
    <li>Domain Driven Design，让非法状态甚至无法表示。</li>
    <li><a href="https://fsharpforfunandprofit.com/posts/recipe-part2/">面向“铁轨”编程</a>：优雅的错误处理方式</li>
  </ul>
</ul>

<h3>Austral</h3>

<ul>
  <li><a href="https://borretti.me/article/introducing-austral">介绍 Austral：一种具有线性类型和能力的系统语言</a></li>
  <ul>
    <li>通过线性类型来保证更强的安全性。</li>
    <li>展现了一个简洁（无歧义）的语言该有的样子。</li>
  </ul>
</ul>

<h3>Haskell</h3>

<p>让抽象更上一层楼，讨论关于抽象的抽象。</p>

<ul>
  <li><a href="https://drsexplorer.gitbooks.io/learnyouahaskell-zh/content/zh-cn/">Haskell 趣学指南</a></li>
  <ul>
    <li>对初学者友好，没有云里雾里的范畴论名词。</li>
    <li>讲了传说中的Functor（我觉得应该叫map-able）和Monad（bind-able）。</li>
  </ul>
</ul>

<h3>Koka</h3>

<p>学术语言。追求简洁正交，并且运行效率也不差。</p>

<ul>
  <li><a href="https://koka-lang.github.io/koka/doc/book.html">The Koka Programming Language</a></li>
  <ul>
    <li>讲了effect是什么，以及如何利用类型系统来约束effect。</li>
    <li>functional but in-place，特定情况下能将函数式风格的代码直接转换成命令式。</li>
    <li>语法规则也挺独特的。</li>
  </ul>

  <li>
    <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2021/03/multip-tr-v4.pdf">
      Generalized Evidence Passing for Effect Handlers
    </a>
  </li>
  <ul>
    <li>讲了effect系统的实现。看完就知道effect的类型为啥写成那样了。</li>
    <li>相关资料：<a href="https://ocaml.org/manual/5.3/effects.html">OCaml中的effect</a></li>
  </ul>
</ul>

<hr>

<p>
  以上的语言大部分都非常冷门，大多数人甚至都没听说过。这是因为它们多数出自学术社区，少为工业界使用。
  然而其中的各种好用的特性正在逐渐被工业界的语言吸收。这里引用cs3110中的一段话：
</p>

<blockquote>
  即使你学了OCaml后，再也不用它编程，你也会对未来有更好的准备。<br />
  函数式语言中的先进特性有一种惊人的趋势：可以预测主流语言的新特性。<br />
  Java在1995年将垃圾回收引入主流，Lisp在1958年就有了。<br />
  Java直到2004年的第5版才引入泛型，ML在1990年就有了。<br />
  一等函数、类型推断和模式匹配在Python、Java和C++等主流语言中被采用，这比函数式语言引入它们要晚得多。
</blockquote>

<p>
  一般的大学教给学生的第一门语言，都是主流语言。但就是因为太主流，导致网上充斥着设计不良的代码。
  学习这些语言需要专业的引导，这就体现出好教材的重要性。
</p>

<p>
  那什么是好的教材呢？好的教材应该：
<ul>
  <li>内容是正确的。除非是为了易于理解而进行的适度简化，并在后续部分解释清。</li>
  <li>顺序是正确的。每次引入一个新的概念，只依赖于前面章节已经讲过的概念，而不依赖后面章节要讲的概念。</li>
</ul>
</p>

<hr>

<h3>C</h3>

<p>远古时代的混沌。可移植的汇编。大学里最广泛的编程语言，大学生们的梦魇。诞生了不少坑人的教材，大学生们太惨了（</p>

<ul>
  <li><a href="https://akaedu.github.io/book/">Linux C编程一站式学习</a>的第一部分</li>
  <ul>
    <li>不是孤立地讲C语言，而是和编译原理、操作系统、计算机体系结构结合起来讲。</li>
  </ul>

  <li>强烈建议同时参考下面的eecs280的<i>机器模型</i>部分。</li>
</ul>

<h3>C++</h3>

<p>稍受约束的混沌，然而依然很混沌。好在大多数人只需要看其中清晰的那一部分。</p>

<ul>
  <li>eecs280（程序设计与数据结构）</li>
  <ul>
    <li><a href="https://eecs280staff.github.io/notes/">课程讲义</a></li>
    <li>开篇详细且形象地介绍了C++的<i>机器模型</i>，其它教程少有。</li>
    <li><a href="https://lobster.eecs.umich.edu/">lobster</a>：在线工具。能一步步地运行代码，同时观察<i>机器模型</i>。</li>
    <li>内容与SICP一脉相承，并讲解了更多C++独有的抽象手段，比如基于模板的泛型、RAII（资源获取即初始化）。</li>
  </ul>
</ul>

<h3>Python</h3>

<p>动态类型，有很多库。一般用于搞统计分析、数值计算、机器学习。由于经过一次回炉重造，改正了不少历史包袱。</p>

<ul>
  <li>计算机程序的构造与解释（SICP）</li>
  <ul>
    <li>南京大学的<a href="https://sicp.pascal-lab.net/">课程网站</a></li>
    <li>选择Python好处是社区资源丰富，但少了“代码即数据”的优雅。</li>
    <li>在掌握抽象技巧前不适合过于深入学习Python。</li>
  </ul>
</ul>

<h3>Lua</h3>

<p>动态类型，小巧简洁。和Scheme有许多相似之处。初看有些杂乱，细看其实是一致的。</p>

<ul>
  <li>Programming in Lua</li>
  <ul>
    <li><a href="https://lua.xfoss.com/lua_tutorial.html">中文版</a></li>
    <li>在编译时对环境、全局变量的处理（第17、23章）</li>
    <li>非对称协程（第25章）</li>
  </ul>
</ul>

<hr>

<h3>其它</h3>

<ul>
  <li>《编码的奥秘》（CODE），从头发明计算机</li>
  <li><a href="https://itanken.github.io/ostep-chinese/">《操作系统导论》</a></li>
  <li><a href="https://space.bilibili.com/88461692/lists">3Blue1Brown</a>的视频：线性代数、微积分、深度学习</li>
  <li><a
      href="https://github.com/GuangfuWang/geometric-deep-learning-chinese-translation-scripts">几何深度学习</a>，从对称性的角度解释几种常见的深度学习架构
  </li>
</ul>

<hr>

<p>
  以上材料并非完全是学习顺序，为了分类做了一些修改。
</p>
